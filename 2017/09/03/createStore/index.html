<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Rèven,pobusama@gmail.com"><title>【话说 Redux 源码（一）】createStore —— 繁华的起点 · REVEN'S BLOG</title><meta name="description" content="这是本 Redux 源码阅读历程的第一篇文章，我们就从 Redux 库的核心文件 —— createStore.js 开始研读。讲道理，Redux 库跟外面其他妖艳的 JS 库不一样，配套注释十分详细，阅读下来就跟读思路清晰的文章感受差不多。嗯，是个正经的 JS 库。
进入正题，store 是 Re"><meta name="keywords" content="Hexo,HTML,CSS,Linux,Javascript"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">REVEN'S BLOG</a></h3><div class="description"><p>把思想炖在生活里，小点火侯</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/pobusama"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/pobusama"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="http://obhagvjtl.bkt.clouddn.com/person-icon2.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【话说 Redux 源码（一）】createStore —— 繁华的起点</a></h3></div><div class="post-content"><p>这是本 <a href="https://github.com/pobusama/redux-source-code-chewing" target="_blank" rel="noopener">Redux 源码阅读历程</a>的第一篇文章，我们就从 Redux 库的核心文件 —— createStore.js 开始研读。讲道理，Redux 库跟外面其他妖艳的 JS 库不一样，<a href="https://github.com/pobusama/redux-source-code-chewing/blob/master/source-code/createStore.js" target="_blank" rel="noopener">配套注释十分详细</a>，阅读下来就跟读思路清晰的文章感受差不多。嗯，是个正经的 JS 库。</p>
<p>进入正题，store 是 Redux 的核心概念，那么它的创造者 —— createStore 函数就应该是核心 API 之一了，你可以<a href="https://github.com/pobusama/redux-source-code-chewing/blob/master/source-code/createStore.js" target="_blank" rel="noopener">预览</a>一下它的源码。不出所料，createStore.js 输出的函数只有一个 —— <code>createStore</code>。而拉到源码文件的最底部，我们发现这个函数最终返回一个对象，对象上面包含 5 个 API：dispatch、subscribe、getState、replaceReducer 和 [$$observable]，我们主要分析前三个。这个对象也就是我们所谓的 <code>store</code>。</p>
<p>那么接下来，我们先回顾一下 <code>createStore</code> 的用法。</p>
<p><strong>提示：</strong> 本文基于 Redux 的 3.6.0 版本</p>
<p>如果用一句话总结 Redux 的基本用法，那便是<strong>创建 store，监听 state 变化，触发 action 使 state 变更</strong>。写一段你不能再熟悉的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="comment">// actionTypes</span></span><br><span class="line"><span class="keyword">const</span> ADD = <span class="string">'add'</span>;</span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD:</span><br><span class="line">            <span class="keyword">return</span> [...state, &#123;...action.payload&#125;];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(todos);</span><br><span class="line"><span class="comment">// 这里定义一个用来打印 state 的函数</span></span><br><span class="line"><span class="keyword">const</span> printState = <span class="function"><span class="params">store</span> =&gt;</span> </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`current state:`</span>, <span class="built_in">JSON</span>.stringify(store.getState()));</span><br><span class="line">printState(store);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里打印出 state 初始值:</span></span><br><span class="line"><span class="comment">* current state: []</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 state 的变化并打印变化后的 state</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    printState(store);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// dispatch</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        text: <span class="string">'learn Redux'</span>,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里打印：</span></span><br><span class="line"><span class="comment">* current state: [&#123;"text":"learn Redux","completed":false&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>运行一下这段代码（<code>npm run demo1</code>），控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current state: []</span><br><span class="line">current state: [&#123;&quot;text&quot;:&quot;learn Redux&quot;,&quot;completed&quot;:false&#125;]</span><br></pre></td></tr></table></figure></p>
<p>由第一行可知，<code>store</code> 创建成功，state 初始化完成。第二行则是说明我们成功使用 <code>dispatch</code> API 改变了 state。<br>回顾完毕，接下来来看看 Redux 是怎么实现这几个 API 的。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="createStore-的参数"><a href="#createStore-的参数" class="headerlink" title="createStore 的参数"></a>createStore 的参数</h3><p>读懂文档是读懂源码的第一步，我们先看下 <code>createStore</code> 的 API 文档（酱油翻译，轻喷⇁_⇁）说了些啥：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个用于管理 state 树的 Redux store 对象。</span></span><br><span class="line"><span class="comment"> * 修改 store 中数据的唯一方式就是调用 store 对象上的 `dispatch()` 方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一个应用只能拥有单一 store。</span></span><br><span class="line"><span class="comment"> * state 树的不同部分会根据 action 作出响应，为了区分这些不同，你可以使用 `combineReducers` </span></span><br><span class="line"><span class="comment"> * 函数将多个 reducer 函数拼装到一个单一的 reducer 函数上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; reducer 一个 return 下一个 state 树的函数，</span></span><br><span class="line"><span class="comment"> * 这个函数接收当前 state 和 action，用来处理当前 state 并产生下一个 state。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; [preloadedState] 初始 state。可选参数，在一般的应用中，该参数可以用于</span></span><br><span class="line"><span class="comment"> * 整合来自服务端的状态，也可以用来保存前一次的用户会话记录（session）。</span></span><br><span class="line"><span class="comment"> * 如果你使用 `combineReducers` 来生产 root reducer 函数，该参数必须是一个和 </span></span><br><span class="line"><span class="comment"> * `combineReducers` 的属性的形式一样的对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; enhancer store 的增强器。可选参数，该参数用于增强 store，我们可以通过</span></span><br><span class="line"><span class="comment"> * 第三方例如中间件、时间旅行、持久化等功能来增强 store。`applyMiddleware()` 是唯一由 Redux </span></span><br><span class="line"><span class="comment"> * 提供的增强器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @returns &#123;Store&#125; 一个 Redux store 对象，通过该对象你可以读取 state，触发 action，</span></span><br><span class="line"><span class="comment"> * 并订阅（监听）state 的更新。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在我们对 createStore 函数的基本用法、参数作用和返回值有了大致的认识，接下来，我们看看 createStore 函数的内部逻辑。</p>
<p>首先我们从参数校验部分巩固对参数的理解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* -------------- createStore 参数校验部分 -------------- */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 参数校验，如果第二个形参传入的是函数，且第三个形参不传，则第二个实参代表 enhancer。</span></span><br><span class="line"><span class="comment">   * 换句话说，preloadedState 是可选配置。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 校验传入的 enhancer 实参是否是函数。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从这里可以看出，enhancer 的一般形式是：</span></span><br><span class="line"><span class="comment">     * const enhancer = (createStore) =&gt; &#123;</span></span><br><span class="line"><span class="comment">     *  //返回一个函数 `finalCreateStore`，用于接收 reducer 和 preloadedState</span></span><br><span class="line"><span class="comment">     *  return function finalCreateStore (reducer, preloadedState) &#123;</span></span><br><span class="line"><span class="comment">     *    //这里可以拿到原 createStore、reducer 和 preloadedState</span></span><br><span class="line"><span class="comment">     *    //然后添加自定义逻辑</span></span><br><span class="line"><span class="comment">     *    //最终返回 store 对象</span></span><br><span class="line"><span class="comment">     *    return createStore(reducer, preloadedState);</span></span><br><span class="line"><span class="comment">     *  &#125; </span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 校验传入的 reducer 实参是否是函数。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//主体部分...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们得出的结论是：</p>
<ol>
<li><code>reducer</code> 是必传参数，类型必须为 <code>function</code>。</li>
<li><code>preloadedState</code> 和 <code>enhancer</code> 是可选参数。</li>
<li><code>enhancer</code> 可选参数的类型必须为 <code>function</code>。</li>
</ol>
<h3 id="createStore-内部变量"><a href="#createStore-内部变量" class="headerlink" title="createStore 内部变量"></a>createStore 内部变量</h3><p>接下来是主体部分，这部分比较多，咱们一步步来，我们先看 createStore 函数内部维护了哪些变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...参数校验部分</span></span><br><span class="line">    <span class="comment">/* -------------- createStore 正片部分 -------------- */</span></span><br><span class="line">    <span class="keyword">var</span> currentReducer = reducer</span><br><span class="line">    <span class="keyword">var</span> currentState = preloadedState</span><br><span class="line">    <span class="keyword">var</span> currentListeners = []</span><br><span class="line">    <span class="keyword">var</span> nextListeners = currentListeners</span><br><span class="line">    <span class="keyword">var</span> isDispatching = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>currentReducer：当前 store 应用的 reducer，默认使用传入的 reducer 参数，可通过 replaceReducer 函数来热替换 currentReducer。</li>
<li>currentState：默认为传入的 preloadedState 参数，可通过 dispatch 函数改变。</li>
<li>currentListeners：当前订阅队列，用以存放通过 subscribe 函数执行的订阅。</li>
<li>nextListeners：subscribe 函数可以订阅或取消订阅，<code>nextListeners</code> 用来存放订阅或取消订阅后的队列。</li>
<li>isDispatching：dispatch 函数的标志位，作用后面会讲到。</li>
</ol>
<p>我们大致了解了这些变量的基本用处。接下来你一定以为我会顺着源码聊到 <code>getState()</code>，哈哈那怎么是我的风格！</p>
<h3 id="触发-state-的变化-——-dispatch"><a href="#触发-state-的变化-——-dispatch" class="headerlink" title="触发 state 的变化 —— dispatch"></a>触发 state 的变化 —— dispatch</h3><p>现在我们再次纵观整个 <code>createStore.js</code> 文件，发现定义 5 个变量之后紧接着定义了几个 API 函数，而<strong>真正执行内部函数的地方，只有靠近文件最底部的 <code>dispatch({ type: ActionTypes.INIT })</code> 这段代码</strong>，我先告诉你这是初始化整个 <code>state</code> 的关键步骤。至于它是怎么初始化 <code>state</code> 的，且看 <code>dispatch</code> 做了些什么：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* -------------- dispatch 参数校验部分 -------------- */</span></span><br><span class="line">    <span class="comment">// action 要求是一个简单对象（plain object）</span></span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">        <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最基础的 dispatch 函数（没有接入三方中间件）接收的 action 对象必须要带 type 参数。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">        <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 标识位，用来锁定 reducer 计算过程，</span></span><br><span class="line"><span class="comment">    * 如果 reducer 计算过程中调用了 dispatch 函数则会报错（为什么不能调用用？请接着往下看）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* -------------- dispatch 正片部分 -------------- */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 这是 Redux 的灵魂部分</span></span><br><span class="line"><span class="comment">       * 作用是将当前 state 和 action 交给 reducer 函数处理，计算出**新的 state**</span></span><br><span class="line"><span class="comment">       * 注意！在 reducer 函数中要避免调用 dispatch </span></span><br><span class="line"><span class="comment">       * 原因类似银行取钱：假设你和女朋友共存了 100 元，在某时刻，你取 10 块钱</span></span><br><span class="line"><span class="comment">       * 此时银行系统便会对你的账户计算：`100 - 10 = 90`</span></span><br><span class="line"><span class="comment">       * 如果计算过程中你女朋友取 20 元，那么银行系统又会计算：`100 - 20 = 80`</span></span><br><span class="line"><span class="comment">       * 那结果到底是 90 还是 80 呢？</span></span><br><span class="line"><span class="comment">       * 当然是 70 ！</span></span><br><span class="line"><span class="comment">       * 银行家的做法是在你 “取钱 -&gt; 结算完毕” 过程中冻结其他存取操作（在本源码中是置 isDispatching 标识位为 true），</span></span><br><span class="line"><span class="comment">       * 你女朋友只能在你 “取钱 -&gt; 结算完毕” 过程以外的时间里取钱。</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">      isDispatching = <span class="literal">true</span> <span class="comment">// 更改过程锁</span></span><br><span class="line">      currentState = currentReducer(currentState, action) <span class="comment">// 将当前 state 和 action 交给 reducer 计算</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 无论计算成功还是报错，最终都将标志位置为 false，以免阻碍下一个 action 的 dipatch。</span></span><br><span class="line">      isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 此时 state 已经更新完毕，我们将订阅队列中的函数一一执行</span></span><br><span class="line"><span class="comment">    * 我们在这些函数里可以拿到更新后的 state。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> listeners = currentListeners = nextListeners</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      listeners[i]()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处设伏笔，在 applyMiddleware 里有妙用。</span></span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<p>现在回头再看看 <code>dispatch({ type: ActionTypes.INIT })</code> 这段代码，你一定已经对他了若指掌了。<br>拿 <code>demo1</code> 中设计的 reducer 函数举例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD:</span><br><span class="line">            <span class="keyword">return</span> [...state, &#123;...action.payload&#125;];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为使用者我们肯定不会针对 <code>ActionTypes.INIT</code> 这个 Redux 内部的 action type 做相应计算，那么 reducer 函数就会直接走 default case 从而返回 currentState。毫无疑问，在 store 初始化的时候，这个 state 要么是 reducer 函数定义的缺省 state（这里是 <code>[]</code>），要么是 createStore 函数中传入的第二个参数 <code>preloadedState</code>。这样我们就完成了 state 的初始化。</p>
<p>在初始化之后，在其他地方触发 <code>dispatch</code> 函数，就是我们熟悉的过程了：通过 action 携带的信息和 currentState 计算 nextState，更新 store 内部的 currentState。</p>
<p>所以我们通过 createStore 函数拿到 store 对象意味着什么呢？结论是：</p>
<ol>
<li>我们在 store 内部已经有了一个 state（currentState）。</li>
<li>我们有 5 个 API 来管理这个 state。</li>
</ol>
<h3 id="获取当前-state-——-getState"><a href="#获取当前-state-——-getState" class="headerlink" title="获取当前 state —— getState"></a>获取当前 state —— getState</h3><p>如何获取当前 state？想必你已经能预测到它的源码是怎么写的了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<h3 id="订阅（监听）state-的变化-——-subscribe"><a href="#订阅（监听）state-的变化-——-subscribe" class="headerlink" title="订阅（监听）state 的变化 —— subscribe"></a>订阅（监听）state 的变化 —— subscribe</h3><p>我们目前有了初始 state，有了更新 state 的方式，还有获取当前 state 的方式。但我们如何监听 state 的变化呢？细心的你肯定已在 dispatch 函数的实现代码中初见端倪了。<br>好我们来看 subscribe 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* -------------- subscribe 参数校验部分 -------------- */</span></span><br><span class="line">    <span class="comment">// listener 必须是函数类型（state 变更以后调用）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -------------- subscribe 正片部分 -------------- */</span></span><br><span class="line">    <span class="comment">// 每次订阅都会维护一个标志位，以便在重复取消订阅的时候提高性能</span></span><br><span class="line">    <span class="keyword">var</span> isSubscribed = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    nextListeners.push(listener)<span class="comment">// 向 listeners 队列中添加订阅函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 防止重复取消订阅时，再次进行下面比较耗费性能的运算</span></span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取消订阅先把标志位置 false</span></span><br><span class="line">      isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      ensureCanMutateNextListeners()</span><br><span class="line">      <span class="comment">// 找到订阅函数在订阅队列中的位置</span></span><br><span class="line">      <span class="keyword">var</span> index = nextListeners.indexOf(listener)</span><br><span class="line">      <span class="comment">// 删除订阅队列中的相应订阅函数。</span></span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略看下来逻辑还是比较清晰的，该 API 提供了订阅和取消订阅的功能，订阅时，向内部维护的订阅队列（nextListeners）中 push 订阅函数。这时候我们回顾一下 dispatch 的部分代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> listeners = currentListeners = nextListeners</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    listeners[i]()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<p>这里在 state 变更后将 nextListeners 数组中的订阅函数按顺序执行，这就完成了订阅 -&gt; 执行订阅函数的流程。</p>
<p>此外，subscribe 返回一个 unsubscribe 函数用于取消订阅。 unsubscribe 利用 subscribe 函数闭包变量 listener，定位到订阅队列的相应位置，然后删除相应订阅函数。</p>
<p>我在 <a href="https://github.com/pobusama/redux-source-code-chewing/tree/master/demo2" target="_blank" rel="noopener"><code>demo2</code></a> 中简单地演示了一下取消订阅的用法，请运行 <code>npm run demo2</code> 查看结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="comment">// ... 以上是相同的代码</span></span><br><span class="line"><span class="comment">// 这回添加了两个监听函数</span></span><br><span class="line"><span class="keyword">const</span> subscribeA = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'subscribeA do this:'</span>)</span><br><span class="line">    printState(store);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> subscribeB = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'subscribeB do this:'</span>)</span><br><span class="line">    printState(store);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 dispatch 后，监听函数依次执行</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        text: <span class="string">'learn Redux'</span>,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这一步打印：</span></span><br><span class="line"><span class="comment">* subscribeA do this:</span></span><br><span class="line"><span class="comment">* current state: [&#123;"text":"learn Redux","completed":false&#125;]</span></span><br><span class="line"><span class="comment">* subscribeB do this:</span></span><br><span class="line"><span class="comment">* current state: [&#123;"text":"learn Redux","completed":false&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 取消 subscribeB 订阅函数</span></span><br><span class="line">subscribeB();</span><br><span class="line"><span class="comment">// 现在执行 dispatch 后，只有 subscribeA 订阅函数会执行。</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        text: <span class="string">'learn React'</span>,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这一步打印：</span></span><br><span class="line"><span class="comment">* subscribeA do this:</span></span><br><span class="line"><span class="comment">* current state: [&#123;"text":"learn Redux","completed":false&#125;,&#123;"text":"learn React",</span></span><br><span class="line"><span class="comment">* "completed":false&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>慢着！我们好像漏看了两行代码！subscribe 函数中出现了两次 <code>ensureCanMutateNextListeners()</code>，它们是干什么用的呢？从字面理解，这行代码用于 “确认可以修改 nextListeners 变量”。还是不懂？没关系！<br>我们把 <code>ensureCanMutateNextListeners()</code> 替换成这个函数具体代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换 ensureCanMutateNextListeners()</span></span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向 listeners 队列中添加订阅函数</span></span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 替换 ensureCanMutateNextListeners()</span></span><br><span class="line">      <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">        nextListeners = currentListeners.slice()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到订阅函数在订阅队列中的位置</span></span><br><span class="line">      <span class="keyword">var</span> index = nextListeners.indexOf(listener)</span><br><span class="line">      <span class="comment">// 删除订阅队列中的相应订阅函数。</span></span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合函数名 “ensureCanMutateNextListeners”，和函数代码，我们可以提出以下两个问题：</p>
<ol>
<li>“确认” 有什么用处呢？</li>
<li>为什么要复制一份 currentListeners 到 nextListeners 上修改，而不是直接在 currentListeners 上修改呢？</li>
</ol>
<p>带着这两个问题，我们回头看一下 subscribe 函数的注释：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加一个订阅 state 变更的监听函数（listener）。该监听函数将会在 action 分发后，</span></span><br><span class="line"><span class="comment">   * state 树完成可能的变更之后被调用。接着你可以在这个回调中通过调用 `getState()` </span></span><br><span class="line"><span class="comment">   * 来读取当前 state。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 你可能会在一个监听函数中调用 `dispatch()`，请知晓以下注意事项：</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 1. 监听函数只应当在响应用户的 actions 或者特殊的条件限制下（比如：在 store 有一个</span></span><br><span class="line"><span class="comment">   * 特殊字段时 dispatch action）才能调用 dispatch()。虽然不作任何条件限制而在监听函数中</span></span><br><span class="line"><span class="comment">   * 调用 dispatch() 在技术上是可行的，但是随着每次 dispatch() 改变 store 可能会导致陷</span></span><br><span class="line"><span class="comment">   * 入无穷的循环。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 2. 在每次调用 `dispatch()` 之前，订阅队列（subscriptions）会保存一份快照。如果你在</span></span><br><span class="line"><span class="comment">   * 订阅函数正在执行的时候订阅或者取消订阅，那这次订阅或取消订阅并不会影响本次 `dispatch()` </span></span><br><span class="line"><span class="comment">   * 过程。但下次调用 `dispatch()` 时，无论其是否嵌套，订阅队列应用都会应用订阅列表里最近的</span></span><br><span class="line"><span class="comment">   * 一次快照。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 3. 因为在监听函数执行前，state 有可能在一个嵌套的 `dispatch()` 中改变多次，所以监听</span></span><br><span class="line"><span class="comment">   * 函数不一定能跟踪到所有的 state 变更。保证所有的监听器都注册在 dispatch() 启动之前，</span></span><br><span class="line"><span class="comment">   * 这样，在调用监听器的时候就会传入监听器所存在时间里最新的一次 state。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param &#123;Function&#125; listener 每当 dispatch action 的时候都会执行的回调函数。</span></span><br><span class="line"><span class="comment">   * @returns &#123;Function&#125; 一个用来移除函数变化监听器的函数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们仔细看第 2 条注意事项，它强调了 “如果你在订阅函数正在执行的时候订阅或者取消订阅，那这次订阅或取消订阅并不会影响本次 <code>dispatch()</code> 过程”。“订阅函数正在执行的时候” 对应的是 dispatch 函数中的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listeners = currentListeners = nextListeners</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    listeners[i]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设想一共有 10 个订阅函数，我们在第 5 个订阅函数执行过程中又增加一个订阅函数。我们知道这段代码是同步执行的，执行到第 5 个时，<strong>循环没有执行完，后面 5 个订阅函数也没有执行</strong>，此时若操作 “listeners”，“currentListeners”，“nextListeners” 任意一个数组变量（他们都指向同一个数组对象的地址），都会影响后面的循环。想要不影响后面的循环？<code>ensureCanMutateNextListeners()</code> 登场。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ensureCanMutateNextListeners()</span></span><br><span class="line"><span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">    nextListeners = currentListeners.slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到 “第 5 个订阅函数”，如果我们在其执行时调用 subscribe 添加或取消订阅函数，此刻 <code>nextListeners === currentListeners</code> 为 true，我们通过 <code>nextListeners = currentListeners.slice()</code> <strong>将当前订阅队列拷贝了一份，获得了新的数组对象地址</strong>，然后赋值给 <code>nextListeners</code>（这里也就是源码注释里所说的 “快照”），用这个数组添加或取消订阅函数。这样丝毫没有影响 <code>listeners</code> 数组的循环过程，一直到执行订阅函数的循环结束。而下一次执行 <code>dispatch()</code> 时，<code>var listeners = currentListeners = nextListeners</code> 这段代码使订阅队列应用 “应用订阅列表里最近的一次快照”，更新了 listeners 变量，接着再循环执行订阅队列。至此，我们完成逻辑上的闭环。</p>
<p>这次我们用 demo3（<code>npm run demo3</code>）来解释这个过程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo3</span></span><br><span class="line"><span class="comment">// ... 以上是相同的代码</span></span><br><span class="line"><span class="comment">// subscribe</span></span><br><span class="line"><span class="keyword">const</span> subscribeA = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    printState(store);</span><br><span class="line">    <span class="comment">//在订阅函数中取消 subscribeA 订阅（改变订阅队列）</span></span><br><span class="line">    subscribeA();</span><br><span class="line">    <span class="comment">//增加 subscribeB 的监听（也会改变订阅队列）</span></span><br><span class="line">    <span class="keyword">const</span> subscribeB = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'subscribeB'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// dispatch</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        text: <span class="string">'learn Redux'</span>,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第一次执行 dispatch，触发 subscribeA 订阅函数</span></span><br><span class="line"><span class="comment">* 这里执行完后打印：current state: [&#123;"text":"learn Redux","completed":false&#125;]</span></span><br><span class="line"><span class="comment">* 说明 dispatch 期间订阅队列没有受到影响</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        text: <span class="string">'learn React'</span>,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第二次 dispatch，应用最近的快照</span></span><br><span class="line"><span class="comment">* 由于取消了 subscribeA 增加了 subscribeB 所以快照里只有 subscribeB。</span></span><br><span class="line"><span class="comment">* 这里执行完后打印：subscribeB</span></span><br><span class="line"><span class="comment">* 说明已经应用了最新的快照</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>现在，我们回答一开始提出的两个问题</p>
<ol>
<li>“确认” 有什么用处呢？—— 确认当前队列和 “快照“ 是否一致，若一致则开辟新的快照。</li>
<li>为什么要复制一份 currentListeners 到 nextListeners 上修改，而不是直接在 currentListeners 上修改呢？ —— 保存 “快照”，屏蔽订阅或取消订阅对当前循环的影响。</li>
</ol>
<p>读到这里我们基本理解了 subscribe 的各种小心思。不过说实话作为框架使用者，我很少直接用到 subscribe 这个 API，它一般是 Redux 与其他库（比如 react）的桥接库（react-redux）的宠儿，参与管理 view 的顶层数据。换句话说，理解了 subscribe 的内部逻辑，以后读 react-redux 库的逻辑会更加轻车熟路，正所谓 “技多不压身” 嘛！</p>
<h3 id="偷梁换柱-——-replaceReducer"><a href="#偷梁换柱-——-replaceReducer" class="headerlink" title="偷梁换柱 —— replaceReducer"></a>偷梁换柱 —— replaceReducer</h3><p>replaceReducer 只做了两件事情，首先用接收的 nextReducer 替换内部的 currentReducer，接着用 <code>dispatch({type: ActionTypes.INIT})</code> 来初始化 state（至于为什么这样初始化，我在 dispatch 小节中有提到）。<br>这个 API 的代码非常简单，但给应用提供的可能性是无穷的，目前我还没遇到直接使用 replaceReducer 的场景，等遇到了再回头来扩充。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 替换当前 Reducer</span></span><br><span class="line"><span class="comment">     * 2. 初始化 state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ActionTypes.INIT</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="observable"><a href="#observable" class="headerlink" title="[$$observable]"></a>[$$observable]</h3><p>这个 API 我并没有在官方文档中找到清晰的解释。同样等遇到了使用场景再回头来看。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，createStore 是 Redux 最核心的部分。它提供创建 store 对象的方式。而 store 对象则是管理应用里唯一一个 state 树的工具。通读 createStore 的源码，我觉得下面几个要点比较重要：</p>
<ol>
<li>createStore 通过函数内存的方式存储 store 需要的变量，可有效隔绝外部影响。</li>
<li>dispatch 通过触发监听函数队列的方式协助 subscribe 实现订阅机制。</li>
<li>rducer 必须要有默认返回对象（一般是当前 state）。</li>
<li>在同一轮订阅函数队列的执行过程中，增加或取消订阅只会影响下次订阅队列执行。这个可以通过 “快照” 的方式来实现。</li>
</ol>
<p>That’s all~</p>
<p>[转载请注明出处]</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-09-03</span><i class="fa fa-tag"></i><a class="tag" href="/categories/技术/" title="技术">技术 </a><a class="tag" href="/tags/react/" title="react">react </a><a class="tag" href="/tags/redux/" title="redux">redux </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2017/09/03/createStore/,REVEN'S BLOG,【话说 Redux 源码（一）】createStore —— 繁华的起点,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/09/03/combineReducers/" title="【话说 Redux 源码（二）】combineReducers —— 涓涓溪流，可成江海">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/07/30/react-forms-controlled-components/" title="翻译 | 玩转 React 表单 —— 受控组件详解">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:true || false, 
  verify:true|| false, 
  app_id:'vPjtr6BKvaz821se9iFDov9m-gzGzoHsz',
  app_key:'nUoDbTcWFKDvvz7r5xPDVwON',
  placeholder:'Just go go',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>